
Small example: investments.json

import frontend._, backend._, core._, core.RationalTools._

val sch = new schema.DynamicSchema
val R   = sch.read("investments.json", Some("k_amount"))
val dc  = new DataCube(RandomizedMaterializationScheme(sch.n_bits, .5, 1.2))
dc.build(CBackend.b.mk(sch.n_bits, R.toIterator))

Exploration.col_names(sch)

val q = sch.columns("company").bits.toList
val result = dc.naive_eval(q)
sch.decode_dim(q).zip(result)

Exploration.dist(sch, dc, "company")

val grp_bits = 2
val q = sch.columns("date").bits.toList.drop(grp_bits)
Exploration.nat_decode_dim(sch, "date", grp_bits).zip(dc.naive_eval(q)).filter(
  x => (x._1(0) >= 1996) && (x._1(0) < 2020))


// exploration example -- unknown file

val sch = new schema.DynamicSchema
val R   = sch.read("../json/Shoppen.json")
val dc  = new DataCube(RandomizedMaterializationScheme(sch.n_bits, .005, 1.02))
dc.build(CBackend.b.mk(sch.n_bits, R.toIterator))

Exploration.col_names(sch)





// "Large" example:

/*
import frontend._
val dc = experiments.Tools.mkDC(100, 0.1, 1.05, 100000, Sampling.f2)
dc.save("s2_d100_100k.dc")
*/

val sch = schema.StaticSchema.mk(100)
val dc = core.DataCube.load("s2_d100_100k.dc")

dc.m.projections
dc.m.projections.map(_.length).groupBy(x => x).mapValues(_.length).toList.sorted

dc.naive_eval(List(0,1,2,3))

val od = OnlineDisplay(sch, dc, PrettyPrinter.formatPivotTable)

od.l_run(List(0,1,2,3), 4)
od.l_run(List(0,1,2,3,4,5), 50)

od.ui.visible = false






